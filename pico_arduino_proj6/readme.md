## Project 6 - SPI microSD logging ##

# Description # 
This project logs sensor data to a microSD card using the Raspberry Pi Pico over SPI. Using the SdFat library, the firmware initializes the card, mounts a FAT filesystem, opens/creates files, and appends time-stamped readings from ADC0 (GPIO26) at a fixed interval. 

# Wiring #
Six pins total, MISO, MOSI, CS, BCLK, VCC, and GND. Not all SPI devices use MISO. 
MISO -> GP16		CS -> GP17		SCLK -> GP18
MOSI -> GP19		VCC -> 3V3		GND -> GND

# How it Works #
SPI: Typically used to transfer and receive data from one smart device to one or several target devices, it’s used for displays, ADC/DACs, flash, sensors, etc. Unlike I²C, SPI has no device addresses. CS is pulled low to tell a target device to activate and send/receive data. With multiple devices, there typically needs to be one CS line per target. When CS is pulled low, data is being sent/received by the controller or target. MOSI is used when data needs to be sent to the target device, the number of bytes sent is dependent upon the implementation. 
MISO is used as a response to data from MOSI if it is sending data back to the controller device. The SCLK is generated by the controller device and determines when data should be sampled, one bit is read per clock signal. SCLK can either be idle HIGH or LOW with data being sampled on either clock polarity (CPOL). MISO does not have its own clock signal, so the master must know how many bits to send so that it can also generate an appropriate number of clock signals for the target device to transmit data. In SPI, the clock has phases o and 1. A clock phase of 0 indicates that data is sampled on the leading edge of the clock signal. A clock phase of 1 means that data is sampled on the trailing edge of each clock pulse. The combinations of CPOL and clock phases give SPI different types of modes which can be distinguished by inspection.
The SPI pins are chosen by the board rather than the sketch, MISO, MOSI, and SCK are fixed pins, but CS still requires a unique pin and declaration in the sketch. These are configured with the SPI object used, SPI.begin(). Additionally, libraries like SdFat use the SPI object to determine which pins belong to MISO, MOSI, and SCK. These three are shared across lines from the master to every target, CS is unique and can go to different boards with different GPIO options, so it has to be declared in the sketch. 
MicroSD Card Adapter: A microSD card is a tiny flash-storage module with a built-in controller that makes raw NAND flash (pages inside big erase blocks) look like a simple 512-byte block device. Electrically it runs at 3.3 V and can speak either SD mode or SPI. SPI is associated with CS, SCK, MOSI, and MISO. Upon startup, ‘dummy ticks’ are sent while CS is high, followed up by a command (reading or writing). For example, a read command sends the hexadecimal data token 0xFE (signalling the start of a data block for an SD interface) and sending 512 bytes plus a 2-bit CRC. These commands are not processed by the code in the sketch, instead they are processed by the SdFat library on sd.begin(), the commands parsed by the microSD card’s internal controller. 
SdFat.h: One library used in the code is SdFat.h, it controls three layers of work, card I/O, filesystems, and API availability. Card I/O consists of sending SD commands, handling of the data token (0xFE), and preventing file corruption by using CRC16. It also handles SPI speed and abstracts 512-byte sectors of read/write. Filesystems have their volume mounted, meaning that metadata, rather direct bits/bytes, are exposed to the files and folders. FAT (File Allocation Table) is a simple disk layout used on SD cards/USB sticks. The card is split into fixed-size blocks called clusters. The table will map each file to the chain of clusters that it belongs to, keeping open/free files and managing cluster spaces. Both the SdFat and SdFile objects created in the code are compatible with Arduino’s print(), so their contents may be displayed. 
